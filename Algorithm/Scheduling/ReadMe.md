# Process Scheduling

 - 좀 더 상세하게 추가하고 다듬자
## 개요

### 정의 
- 컴퓨터 시스템의 모든 자원을 효율적으로 사용하기 위한 프로세스 관리정책
- 다중 프로그래밍을 가능하게 하는 OS의 동작 기법
- 하나의 CPU가 다수의 프로세스(실행 중인 프로그램의 인스턴스)를 일련의 기준을 통해 실행 방식을 정함 
- 시간 분할 - 여러 프로세스들 동시 작업 수행시 같은 자원 번갈아 사용(시분할시스템)
- 공간 분할 - 하나의 자원을 분할하여 동시에 같이 사용(자원관리)

### 목적 
- 컴퓨터 시스템의 성능향상

### 배경
- 다중프로그래밍을 지원하는 os에서 프로세서를 효율적으로 관리하기 위해 필요

## 프로세스 상태
 - 프로세스의 5가지 상태
 - 생성(Create) 
    - 프로세스가 생성되고 있는 상태
 - 실행(Running)
    - 프로세스가 프로세서를 차지하여 명령어들이 실행되고 있는 상태
 - 준비(Ready)
    - 프로세스가 프로세서를 사용하고 있지는 않지만 언제든지 사용할 수 있는 상태로, CPU가 할당되기를 기다리고 있는 상태
 - 대기(Waiting)
    - 프로세스가 입출력 완료, 시그널 수신 등 어떤 사건을 기다리고 있는 상태
 - 종료(Terminated)
    - 프로세스의 실행이 종료된 상태

- 운영체제는 CPU 스케줄러를 통해 준비 큐(준비 상태에 있는 프로세스들을 모아놓은 큐)에 있는 프로세스 중 한 프로세스를 골라 다음에 실행시킴.
  
## 성능지표
1. 응답시간  
2. 작업처리량      
3. 자원활용도
4. 공평성    
5. 예견성(예측시간) 
6. 무기한 연기 방지(*에이징 기법으로 해결)
- *aging 기법 : 대기시간 경과할수록 대기하는 프로세스의 우선순위를 높여줌.

##  스케줄링 기준(고려항목)
1. 프로세스 속성  
2. 시스템 속성  
3. 응답시간 중요성
4. 우선순위  
5. 총 실행시간 
6. 활용 목적

## 프로세스 스케줄러

 - 프로세스 스케줄러는 OS의 일부로 특정 시점에서 어떤 프로세스가 실행되는지 결정

 - 스케줄링 단계 
1. 장기 스케줄링 
     - 프로세스의 여러 가지 정보 종합하여 작업순서 결정
     - 시스템에 입력되는 작업이나 명령 등의 커널 등록 순서 결정
     - FIFO 방식 주로 사용
     - 우선순위, 예측 수행시간, 입출력 요구사항 등 종합
     - 커널에 등록되기 전을 처리

2. 중기스케줄링 
     - 프로세서를 경쟁하는 프로세스 수 줄여 다중 프로그래밍 차수 완화
     - 프로세스들에 대해 주기억장치 할당순서 결정(swap in/out)
     - 프로세스에게 기억장치 할당
   
3. 단기스케줄링 
     - 프로세스 스케줄링
     - 어느 프로세스에게 프로세서를 할당할 것인가 결정
     - 스케줄링 수행(입출력 인터럽트, 클럭 인터럽트, 시스템 호출)
     - 프로세서 실행부분

## 스케줄링 정책

1. 선점/비선점 정책
 - 스케쥴링 적용 시점에 따라 구분

 ||비선점 | 선점|
 |-|-|-|
 |개요|자원 스스로 반납시 까지 냅둠|자원을 정해진 법칙에 따라 돌아가며 사용|
 |장점|종료시간 비교적 정확한 예측|OS가 프로세스에 할당되었던 CPU를 자체적으로 판단하여 가져올수있음|
 |단점|우선순위 안지켜질 수 있음(평균시간 up)|문맥교환을 위한 오버헤드가 증가|

2. 우선 순위 정책
  - 프로세스의 우선순위 변동 여부에 따라 구분
  - 프로세스 중요도 숫자로 표현
   
 |이름|특징|
 |-|-|
 |정적 우선순위|프로세서 생성시 부여, 실행 중 불변, 구현이 단순하여 오버헤드가 적음, 시스템 환경 변화 적절한 대응이 어려움|
 |동적 우선순위|프로세서 생성시 초기값 부여, 시스템 변화에 따라 순위 변경, 구현이 복잡하고 우선순위 계산에 의한 오버헤드가 큼, 시스템 환경 변화에 유연한 대응 가능|
 |매입 우선순위|고급 서비스 제공위해 우선순위를 매입함, 정적/ 동적 우선순위와 함께 사용|

## 스케쥴링 알고리즘

1. FIFO(First in First out) 스케줄링  

- 비선점 스케줄링
- 준비상태에 먼저 도착한 프로세스가 먼저 프로세서를 할당받로고 하고 스스로 프로세서를 반납할때까지 독점하도록 함
- 자원효율성 up
- 일괄처리시스템에 적합
- 평균응답시간 길어질 수 잇음 (응답시간 = 프로세싱 시간 – 도착시간)

2. RR(Round Robin) 스케줄링

- 선점 스케줄링
- 시간할당량 지정(끝나면 준비상태로 전이)
- 프로세서 독점 방지 but, 문맥교환 오버헤드 감수
- 평균응답시간(들어왔다가 끝나는시간)

3. SPN(Shortest Job First) 스케줄링

- 비선점
- 총 실행 시간 가장 짧은 프로세스부터 스케줄링
- 평균 대기시간 최소화, 빠른 응답시간(주로 비교대상이 됨)
- 실제 적용 힘듬(총 실행시간 예측 불가, 실행시간 추정 작업 필요)
- 무기한 연기 발생 가능( aging 기법 필요)

4. SRTN(Shortest Remaining Time Next) 스케줄링
- 준비상태 프로세스들 중 작업 완료까지 가장 적은 시간 필요하는 프로세스에게 프로세서 할당(SPN 기법 변형)
- 선점 정책 기반(프로세스 실행중 남은 시간 더 적은 프로세스가 선점)
- 총 실행 시간 추정 작업 필요, 잔여 실행 시간 계산 필요(오버헤드 증가)
- 실행 시간 긴 프로세스 응답시간 증가, 잦은 선점으로 인한 문맥교환 유발

5. HRRN(High Response Ratio Next) 스케줄링
- SPN기법의 실행시간 긴 프로세스와 짧은 프로세스간의 불평등 심화 방지 기법
- 응답률이 가장 높은 프로세스에게 우선권 줌
- 응답률 = (서비스시간+대기시간)/서비스시간
- 응답률을 우선순위로 사용 (응답률이 높을수록 우선권 높음)

6. 다단계 피드백 큐(MFQ : Multi level Feedback Queue)
- 스케줄링 대상인 프로세스들에 대한 특성이나 총 실행시간 정보가 없는 경우 사용
- ready큐를 여러개 둠
    - 짧은 실행 시간 필요로 하는 프로세스 선호(입출력 위주 프로세스 선호)
    - 프로세스 성격 분석, 적응성 있게 스케줄링

- 현재까지 프로세서를 사용한 시간을 근거로 스케줄링(피드백)
- 장점 
   - 매우 적응성 있는 기법
   - 프로세스들에 대한 사전정보 없어도 SPN, SRTN, HRRN 등의 효과
- 단점
   - 시스템 부하 증가
   - 실행시간이 긴 프로세스는 응답시간이 길어짐

- 입출력 위주 프로세스를 상위큐로 이동(우선순위 높임)
- 지정된 대기시간 초과한 프로세스는 상위큐로 이동
- 준비큐가 여러개인데 우선순위별로 나뉨. (우선순위 :커널수준[입출력위주] > 사용자수준)
- 무기한 연기현상 발생가능
- 준비큐마다 할당시간 다르게 설정
- 그래서 시간할당량을 배정하고 이 때문에 우선순위 조정이 됨

7. 유닉스 운영체제 스케줄링기법(MFQ 스케줄링 기법 변형)

- 대화형 사용자들이 생성하는 프로세스들에게 최소 응답시간 제공이 주 목적
- 모든 사용자들에게 공평성을 제공해야함 ->우선순위 기반의 스케줄링
- 커널 우선순위 > 사용자 우선순위 (이 우선순위는 불변)
- 클럭핸들러가 주기적으로 인터럽트를 발생시켜 모든 프로세스들의 우선순위 조정
- Decay 연산
    - CPUCount <- CPUCount/2 (cpu할당순서 낮을수록 할당순서 빠름)
- 우선순위 조정
    - Prioirty <- CPUCount/2 + basePriority[기존 우선순위] + (niceValue)
- 스케줄링 기법
    - 주어진 우선순위를 기반으로 하여 우선순위가 높은(숫자가 낮은) 순으로 처리함
    - 클럭 마다 우선순위 조정
    - MFQ 기반의 기법임

8. 정리
- SPN 스케줄링 : 실행시간이 적은 프로세스부터 처리
- SRTN 스케줄링 : 서비스시간(남은시간)이 적은 프로세스부터 처리
- HRRN 스케줄링 : 응답률이 가장 높은 프로세스부터 처리
- MFQ 스케줄링 : 우선순위가 다른 큐를 여러 개 만들어 프로세스를 처리
- UNIX 스케줄링 : CPUCount를 이용해 우선순위를 계산하여 프로세스를 처리